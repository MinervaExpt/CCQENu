\hypertarget{_sep18_2_hist2_d_wrapper_map_8h_source}{}\doxysection{Hist2\+DWrapper\+Map.\+h}
\label{_sep18_2_hist2_d_wrapper_map_8h_source}\index{make\_hists/include/Sep18/Hist2DWrapperMap.h@{make\_hists/include/Sep18/Hist2DWrapperMap.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//}}
\DoxyCodeLine{2 \textcolor{comment}{//  Hist2DWrapperMap.h}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{//}}
\DoxyCodeLine{5 \textcolor{comment}{//  Created by Heidi Schellman (research) on 11/4/16.}}
\DoxyCodeLine{6 \textcolor{comment}{//  Modified by Noah Vaughan for 2D, 1/12/21}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{comment}{// make a map of histwrappers with the same name title and binning.}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef Hist2DWrapperMap\_h}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define Hist2DWrapperMap\_h}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define HSTDBG}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}PlotUtils/Hist2DWrapper.h"{}}}
\DoxyCodeLine{17 \textcolor{comment}{//\#include "{}PlotUtils/DefaultCVUniverse.h"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}MinervaUnfold/MnvResponse.h"{}} \textcolor{comment}{//need to check on this}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{namespace }PlotUtils\{}
\DoxyCodeLine{26 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{keyword}{class }Hist2DWrapperMap:\textcolor{keyword}{public} T \{}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{private}:}
\DoxyCodeLine{31 }
\DoxyCodeLine{32   std::map<const std::string, Hist2DWrapper<T> > m\_hists;}
\DoxyCodeLine{33   std::map< std::string, std::vector<T*> > m\_univs;}
\DoxyCodeLine{34   std::string m\_name = \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{35   std::string m\_title = \textcolor{stringliteral}{"{}NULL"{}};}
\DoxyCodeLine{36   \textcolor{keywordtype}{int} m\_nxbins = 0;}
\DoxyCodeLine{37   \textcolor{keywordtype}{double} m\_xmin = 0.0;}
\DoxyCodeLine{38   \textcolor{keywordtype}{double} m\_xmax = 0.0;}
\DoxyCodeLine{39   std::vector<Double\_t> m\_xbins;}
\DoxyCodeLine{40   \textcolor{keywordtype}{int} m\_nybins = 0;}
\DoxyCodeLine{41   \textcolor{keywordtype}{double} m\_ymin = 0.0;}
\DoxyCodeLine{42   \textcolor{keywordtype}{double} m\_ymax = 0.0;}
\DoxyCodeLine{43   std::vector<Double\_t> m\_ybins;}
\DoxyCodeLine{44   \textcolor{keywordtype}{int} m\_nxrecobins = 0;}
\DoxyCodeLine{45   \textcolor{keywordtype}{double} m\_xrecomin = 0.0;}
\DoxyCodeLine{46   \textcolor{keywordtype}{double} m\_xrecomax = 0.0;}
\DoxyCodeLine{47   std::vector<Double\_t> m\_xrecobins;}
\DoxyCodeLine{48   \textcolor{keywordtype}{int} m\_nyrecobins = 0;}
\DoxyCodeLine{49   \textcolor{keywordtype}{double} m\_yrecomin = 0.0;}
\DoxyCodeLine{50   \textcolor{keywordtype}{double} m\_yrecomax = 0.0;}
\DoxyCodeLine{51   std::vector<Double\_t> m\_yrecobins;}
\DoxyCodeLine{52   std::map< std::string, std::vector<T*> > m\_universes;  \textcolor{comment}{// if you are using a vector need to add that}}
\DoxyCodeLine{53   std::map< std::string, MinervaUnfold::MnvResponse *> m\_response; \textcolor{comment}{//Need to check how 2D response is done}}
\DoxyCodeLine{54   \textcolor{keywordtype}{bool} m\_fixedbins;}
\DoxyCodeLine{55   \textcolor{keywordtype}{int} m\_count;}
\DoxyCodeLine{56   std::map<const std::string, bool> m\_hashist;}
\DoxyCodeLine{57   std::map<const std::string, bool> m\_hasresponse;}
\DoxyCodeLine{58   std::vector<std::string> m\_tags;}
\DoxyCodeLine{59   std::map<const std::string,int> m\_response\_bands; \textcolor{comment}{// map that tells you how many}}
\DoxyCodeLine{60   std::map<const T*,int> m\_decoder;}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 \textcolor{keyword}{public}:}
\DoxyCodeLine{63 }
\DoxyCodeLine{64   Hist2DWrapperMap()\{\};}
\DoxyCodeLine{65   \textcolor{comment}{// constructor}}
\DoxyCodeLine{66   \textcolor{comment}{//fixed bins}}
\DoxyCodeLine{67   \textcolor{keyword}{inline} Hist2DWrapperMap( \textcolor{keyword}{const} std::string name, \textcolor{keyword}{const} std::string title, \textcolor{keyword}{const} Int\_t nxbins, \textcolor{keyword}{const} \textcolor{keywordtype}{double} xmin, \textcolor{keyword}{const} \textcolor{keywordtype}{double} xmax, \textcolor{keyword}{const} Int\_t nybins, \textcolor{keyword}{const} \textcolor{keywordtype}{double} ymin, \textcolor{keyword}{const} \textcolor{keywordtype}{double} ymax, std::map< std::string,std::vector<T*>> univs, \textcolor{keyword}{const} std::vector<std::string> tags)\{}
\DoxyCodeLine{68     \textcolor{comment}{// just store the config}}
\DoxyCodeLine{69 \textcolor{preprocessor}{\#ifdef HSTDBG}}
\DoxyCodeLine{70       std::cout << \textcolor{stringliteral}{"{} standard constructor"{}} << std::endl;}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{72     m\_name = name;}
\DoxyCodeLine{73     m\_title = title;}
\DoxyCodeLine{74     m\_nxbins = nxbins;}
\DoxyCodeLine{75     m\_xmin = xmin;}
\DoxyCodeLine{76     m\_xmax = xmax;}
\DoxyCodeLine{77     m\_nybins = nxbins;}
\DoxyCodeLine{78     m\_ymin = ymin;}
\DoxyCodeLine{79     m\_ymax = ymax;}
\DoxyCodeLine{80       }
\DoxyCodeLine{81     m\_nxrecobins = nxbins;}
\DoxyCodeLine{82     m\_xrecomin = xmin;}
\DoxyCodeLine{83     m\_xrecomax = xmax;}
\DoxyCodeLine{84     m\_nyrecobins = nxbins;}
\DoxyCodeLine{85     m\_yrecomin = ymin;}
\DoxyCodeLine{86     m\_yrecomax = ymax;}
\DoxyCodeLine{87     m\_fixedbins = \textcolor{keyword}{true};}
\DoxyCodeLine{88     \textcolor{comment}{//    m\_count = 0;}}
\DoxyCodeLine{89     m\_univs = univs;}
\DoxyCodeLine{90     m\_tags = tags;}
\DoxyCodeLine{91     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} tag : tags)\{}
\DoxyCodeLine{92      \textcolor{comment}{// std::string hist\_name = tag +"{}\_"{}+ name;}}
\DoxyCodeLine{93       std::string hist\_name =  \textcolor{stringliteral}{"{}h2D\_\_\_"{}}+tag + \textcolor{stringliteral}{"{}\_\_\_"{}}+ name;}
\DoxyCodeLine{94       m\_hists[tag] = PlotUtils::Hist2DWrapper<T>(hist\_name.c\_str(), title.c\_str(), nxbins, xmin, xmax, nybins, ymin, ymax, univs);}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96     m\_decoder = UniverseDecoder(univs);}
\DoxyCodeLine{97 }
\DoxyCodeLine{98   \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 }
\DoxyCodeLine{101   \textcolor{comment}{// constructor}}
\DoxyCodeLine{102   \textcolor{comment}{// variable bins}}
\DoxyCodeLine{103   \textcolor{keyword}{inline} Hist2DWrapperMap( \textcolor{keyword}{const} std::string name, \textcolor{keyword}{const} std::string title, \textcolor{keyword}{const} std::vector<double> xbins,  \textcolor{keyword}{const} std::vector<double> ybins, std::map< std::string, std::vector<T*> > univs, std::vector<std::string> tags)\{ \textcolor{comment}{//2DWrapper doesn't need number of bins for variable bin width}}
\DoxyCodeLine{104     \textcolor{comment}{// just store the config}}
\DoxyCodeLine{105     m\_name = name;}
\DoxyCodeLine{106     m\_title = title;}
\DoxyCodeLine{107     m\_xbins  = xbins;}
\DoxyCodeLine{108     m\_ybins  = ybins;}
\DoxyCodeLine{109     m\_xrecobins  = xbins;}
\DoxyCodeLine{110     m\_yrecobins  = ybins;}
\DoxyCodeLine{111     m\_fixedbins = \textcolor{keyword}{false};}
\DoxyCodeLine{112     \textcolor{comment}{//    m\_count = 0 ;}}
\DoxyCodeLine{113     m\_univs = univs;}
\DoxyCodeLine{114     m\_tags = tags;}
\DoxyCodeLine{115     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} tag : tags)\{}
\DoxyCodeLine{116       \textcolor{comment}{//std::string hist\_name = name+"{}\_"{}+ tag;}}
\DoxyCodeLine{117       std::string hist\_name = \textcolor{stringliteral}{"{}h2D\_\_\_"{}}+tag + \textcolor{stringliteral}{"{}\_\_\_"{}} + name;}
\DoxyCodeLine{118       m\_hists[tag] = PlotUtils::Hist2DWrapper<T>(hist\_name.c\_str(), title.c\_str(), xbins, ybins, univs);}
\DoxyCodeLine{119       m\_hashist[tag] = \textcolor{keyword}{true};}
\DoxyCodeLine{120     \}}
\DoxyCodeLine{121     m\_decoder = UniverseDecoder(univs);}
\DoxyCodeLine{122   \}}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 }
\DoxyCodeLine{125     \textcolor{comment}{// constructor}}
\DoxyCodeLine{126     \textcolor{comment}{//fixed bins}}
\DoxyCodeLine{127     \textcolor{comment}{// constructor  This one is special for reconstructed/tuned MC so you can build a response.}}
\DoxyCodeLine{128     \textcolor{keyword}{inline} Hist2DWrapperMap( \textcolor{keyword}{const} std::string name, \textcolor{keyword}{const} std::string title, \textcolor{keyword}{const} Int\_t nxbins, \textcolor{keyword}{const} \textcolor{keywordtype}{double} xmin, \textcolor{keyword}{const} \textcolor{keywordtype}{double} xmax, \textcolor{keyword}{const} Int\_t nybins, \textcolor{keyword}{const} \textcolor{keywordtype}{double} ymin, \textcolor{keyword}{const} \textcolor{keywordtype}{double} ymax, \textcolor{keyword}{const} Int\_t nxrecobins, \textcolor{keyword}{const} \textcolor{keywordtype}{double} xrecomin, \textcolor{keyword}{const} \textcolor{keywordtype}{double} xrecomax, \textcolor{keyword}{const} Int\_t nyrecobins, \textcolor{keyword}{const} \textcolor{keywordtype}{double} yrecomin, \textcolor{keyword}{const} \textcolor{keywordtype}{double} yrecomax, std::map< std::string,std::vector<T*>> univs, \textcolor{keyword}{const} std::vector<std::string> tags)\{}
\DoxyCodeLine{129       \textcolor{comment}{// just store the config}}
\DoxyCodeLine{130       m\_name = name;}
\DoxyCodeLine{131       m\_title = title;}
\DoxyCodeLine{132       m\_nxbins = nxbins;}
\DoxyCodeLine{133       m\_xmin = xmin;}
\DoxyCodeLine{134       m\_xmax = xmax;}
\DoxyCodeLine{135       m\_nybins = nxbins;}
\DoxyCodeLine{136       m\_ymin = ymin;}
\DoxyCodeLine{137       m\_ymax = ymax;}
\DoxyCodeLine{138         m\_nxrecobins = nxrecobins;}
\DoxyCodeLine{139         m\_xrecomin = xrecomin;}
\DoxyCodeLine{140         m\_xrecomax = xrecomax;}
\DoxyCodeLine{141         m\_nyrecobins = nxrecobins;}
\DoxyCodeLine{142         m\_yrecomin = yrecomin;}
\DoxyCodeLine{143         m\_yrecomax = yrecomax;}
\DoxyCodeLine{144       m\_fixedbins = \textcolor{keyword}{true};}
\DoxyCodeLine{145       \textcolor{comment}{//    m\_count = 0;}}
\DoxyCodeLine{146       m\_univs = univs;}
\DoxyCodeLine{147       m\_tags = tags;}
\DoxyCodeLine{148       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} tag : tags)\{}
\DoxyCodeLine{149        \textcolor{comment}{// std::string hist\_name = tag +"{}\_"{}+ name;}}
\DoxyCodeLine{150         std::string hist\_name =  \textcolor{stringliteral}{"{}h2D\_\_\_"{}}+tag + \textcolor{stringliteral}{"{}\_\_\_"{}}+ name;}
\DoxyCodeLine{151         m\_hists[tag] = PlotUtils::Hist2DWrapper<T>(hist\_name.c\_str(), title.c\_str(), nxbins, xmin, xmax, nybins, ymin, ymax, univs);}
\DoxyCodeLine{152       \}}
\DoxyCodeLine{153       m\_decoder = UniverseDecoder(univs);}
\DoxyCodeLine{154 }
\DoxyCodeLine{155     \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 }
\DoxyCodeLine{158     \textcolor{comment}{// constructor}}
\DoxyCodeLine{159     \textcolor{comment}{// variable bins}}
\DoxyCodeLine{160     \textcolor{comment}{// constructor  This one is special for reconstructed/tuned MC so you can build a response.}}
\DoxyCodeLine{161     \textcolor{keyword}{inline} Hist2DWrapperMap( \textcolor{keyword}{const} std::string name, \textcolor{keyword}{const} std::string title, \textcolor{keyword}{const} std::vector<double> xbins,  \textcolor{keyword}{const} std::vector<double> ybins, std::vector<double> xrecobins,  \textcolor{keyword}{const} std::vector<double> yrecobins, std::map< std::string, std::vector<T*> > univs, std::vector<std::string> tags)\{ \textcolor{comment}{//2DWrapper doesn't need number of bins for variable bin width}}
\DoxyCodeLine{162       \textcolor{comment}{// just store the config}}
\DoxyCodeLine{163       m\_name = name;}
\DoxyCodeLine{164       m\_title = title;}
\DoxyCodeLine{165       m\_xbins  = xbins;}
\DoxyCodeLine{166       m\_ybins  = ybins;}
\DoxyCodeLine{167       m\_xrecobins  = xrecobins;}
\DoxyCodeLine{168       m\_yrecobins  = yrecobins;}
\DoxyCodeLine{169 }
\DoxyCodeLine{170       m\_fixedbins = \textcolor{keyword}{false};}
\DoxyCodeLine{171       \textcolor{comment}{//    m\_count = 0 ;}}
\DoxyCodeLine{172       m\_univs = univs;}
\DoxyCodeLine{173       m\_tags = tags;}
\DoxyCodeLine{174       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} tag : tags)\{}
\DoxyCodeLine{175         \textcolor{comment}{//std::string hist\_name = name+"{}\_"{}+ tag;}}
\DoxyCodeLine{176         std::string hist\_name = \textcolor{stringliteral}{"{}h2D\_\_\_"{}}+tag + \textcolor{stringliteral}{"{}\_\_\_"{}} + name;}
\DoxyCodeLine{177         m\_hists[tag] = PlotUtils::Hist2DWrapper<T>(hist\_name.c\_str(), title.c\_str(), xrecobins, yrecobins, univs);}
\DoxyCodeLine{178         m\_hashist[tag] = \textcolor{keyword}{true};}
\DoxyCodeLine{179       \}}
\DoxyCodeLine{180       m\_decoder = UniverseDecoder(univs);}
\DoxyCodeLine{181     \}}
\DoxyCodeLine{182 }
\DoxyCodeLine{183 }
\DoxyCodeLine{184   \textcolor{comment}{// map that helps you find the index of a universe.}}
\DoxyCodeLine{185   std::map<const T*,int> UniverseDecoder(\textcolor{keyword}{const} std::map< std::string, std::vector<T*> > univs)\textcolor{keyword}{const}\{}
\DoxyCodeLine{186     std::map<const T*, int> decoder;}
\DoxyCodeLine{187     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} univ:univs)\{}
\DoxyCodeLine{188       std::string name = univ.first;}
\DoxyCodeLine{189       std::vector<T*> pointers = univ.second;}
\DoxyCodeLine{190       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < pointers.size(); i++)\{}
\DoxyCodeLine{191         decoder[pointers[i]] = i;}
\DoxyCodeLine{192       \}}
\DoxyCodeLine{193     \}}
\DoxyCodeLine{194     \textcolor{keywordflow}{return} decoder;}
\DoxyCodeLine{195   \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 }
\DoxyCodeLine{198 }
\DoxyCodeLine{199   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} AppendName(\textcolor{keyword}{const} std::string n, \textcolor{keyword}{const} std::vector<std::string> tags)\{}
\DoxyCodeLine{200       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} tag : tags)\{}
\DoxyCodeLine{201         m\_hists[tag].hist-\/>SetName(Form(\textcolor{stringliteral}{"{}\%s\_\_\_\%s"{}},(m\_hists[tag].hist-\/>GetName()),n.c\_str()));}
\DoxyCodeLine{202       \}}
\DoxyCodeLine{203   \}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} AddResponse2D(std::vector<std::string> tags, std::string tail=\textcolor{stringliteral}{"{}"{}})\{ \textcolor{comment}{//TODO: This name okay?}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207     \textcolor{comment}{// make a temp universe map to make Response happy}}
\DoxyCodeLine{208     std::map<std::string, int> response\_bands; \textcolor{comment}{// necessary?}}
\DoxyCodeLine{209     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} band : m\_univs)\{}
\DoxyCodeLine{210       std::string name = band.first;}
\DoxyCodeLine{211       \textcolor{keyword}{const} std::string realname = (band.second)[0]-\/>ShortName();}
\DoxyCodeLine{212       \textcolor{keywordtype}{int} nuniv = band.second.size();}
\DoxyCodeLine{213 }
\DoxyCodeLine{214       m\_response\_bands[realname] = nuniv;}
\DoxyCodeLine{215     \}}
\DoxyCodeLine{216     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} tag:tags)\{}
\DoxyCodeLine{217       \textcolor{comment}{//std::string resp\_name = tag+"{}\_response\_"{}+m\_name;}}
\DoxyCodeLine{218       std::string resp\_name = \textcolor{stringliteral}{"{}h2D\_\_\_"{}}+ tag + \textcolor{stringliteral}{"{}\_\_\_"{}}+m\_name+\textcolor{stringliteral}{"{}\_\_\_response"{}}+tail;}
\DoxyCodeLine{219 }
\DoxyCodeLine{220       \textcolor{keywordflow}{if} (m\_fixedbins)\{}
\DoxyCodeLine{221         TH2D tmp = TH2D(\textcolor{stringliteral}{"{}tmp"{}}, m\_title.c\_str(), m\_nxbins, m\_xmin, m\_xmax, m\_nybins, m\_ymin, m\_ymax);}
\DoxyCodeLine{222         TH2D recotmp = TH2D(\textcolor{stringliteral}{"{}recotmp"{}}, m\_title.c\_str(), m\_nxrecobins, m\_xrecomin, m\_xrecomax, m\_nyrecobins, m\_yrecomin, m\_yrecomax);}
\DoxyCodeLine{223           }
\DoxyCodeLine{224         std::vector<Double\_t> xedges;}
\DoxyCodeLine{225         std::vector<Double\_t> yedges;}
\DoxyCodeLine{226         std::vector<Double\_t> xrecoedges;}
\DoxyCodeLine{227         std::vector<Double\_t> yrecoedges;}
\DoxyCodeLine{228         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= m\_nxbins+1; i++)\{}
\DoxyCodeLine{229           xedges.push\_back(tmp.GetXaxis()-\/>GetBinLowEdge(i));}
\DoxyCodeLine{230         \}}
\DoxyCodeLine{231         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= m\_nybins+1; i++)\{}
\DoxyCodeLine{232           yedges.push\_back(tmp.GetYaxis()-\/>GetBinLowEdge(i));}
\DoxyCodeLine{233         \}}
\DoxyCodeLine{234         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= m\_nxrecobins+1; i++)\{}
\DoxyCodeLine{235             xrecoedges.push\_back(recotmp.GetXaxis()-\/>GetBinLowEdge(i));}
\DoxyCodeLine{236         \}}
\DoxyCodeLine{237         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= m\_nyrecobins+1; i++)\{}
\DoxyCodeLine{238             yrecoedges.push\_back(recotmp.GetYaxis()-\/>GetBinLowEdge(i));}
\DoxyCodeLine{239         \}}
\DoxyCodeLine{240         m\_response[tag] = \textcolor{keyword}{new} MinervaUnfold::MnvResponse(resp\_name.c\_str(), resp\_name.c\_str(), m\_nxrecobins, \&xrecoedges[0], m\_nyrecobins, \&yrecoedges[0], m\_nxbins, \&xedges[0], m\_nybins, \&yedges[0], m\_response\_bands);}
\DoxyCodeLine{241         \textcolor{comment}{//Reco is first set of bin params, truth is second set}}
\DoxyCodeLine{242       \}}
\DoxyCodeLine{243       \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{244         m\_nxbins = m\_xbins.size()-\/1;}
\DoxyCodeLine{245         m\_nybins = m\_ybins.size()-\/1;}
\DoxyCodeLine{246         m\_nxrecobins = m\_xrecobins.size()-\/1;}
\DoxyCodeLine{247         m\_nyrecobins = m\_yrecobins.size()-\/1;}
\DoxyCodeLine{248         m\_response[tag] = \textcolor{keyword}{new} MinervaUnfold::MnvResponse(resp\_name.c\_str(), resp\_name.c\_str(), m\_nxrecobins, \&m\_xrecobins[0], m\_nyrecobins, \&m\_yrecobins[0], m\_nxbins, \&m\_xbins[0], m\_nybins, \&m\_ybins[0], m\_response\_bands);}
\DoxyCodeLine{249       \}}
\DoxyCodeLine{250       m\_hasresponse[tag] = \textcolor{keyword}{true};}
\DoxyCodeLine{251     \}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253 }
\DoxyCodeLine{254 }
\DoxyCodeLine{255 }
\DoxyCodeLine{256   \};}
\DoxyCodeLine{257 }
\DoxyCodeLine{258  }
\DoxyCodeLine{259 }
\DoxyCodeLine{260   \textcolor{comment}{//  can we make this smarter?}}
\DoxyCodeLine{261   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} Fill2D(\textcolor{keyword}{const} std::string tag, \textcolor{keyword}{const} T* universe, \textcolor{keyword}{const} Double\_t x\_value, \textcolor{keyword}{const} Double\_t y\_value, \textcolor{keyword}{const} Double\_t weight, \textcolor{keyword}{const} Double\_t scale=1.0)\{}
\DoxyCodeLine{262 }
\DoxyCodeLine{263     m\_hists[tag].FillUniverse(universe, x\_value, y\_value, weight*scale);}
\DoxyCodeLine{264   \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} FillResponse2D(\textcolor{keyword}{const} std::string tag, \textcolor{keyword}{const} T* univ, \textcolor{keyword}{const} \textcolor{keywordtype}{double} x\_value, \textcolor{keyword}{const} \textcolor{keywordtype}{double} y\_value, \textcolor{keyword}{const} \textcolor{keywordtype}{double} x\_truth, \textcolor{keyword}{const} \textcolor{keywordtype}{double} y\_truth, \textcolor{keyword}{const} \textcolor{keywordtype}{double} weight, \textcolor{keyword}{const} \textcolor{keywordtype}{double} scale=1.0)\{ \textcolor{comment}{//TODO}}
\DoxyCodeLine{267     std::string name = univ-\/>ShortName();}
\DoxyCodeLine{268     \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"{}cv"{}} || name == \textcolor{stringliteral}{"{}CV"{}})\{}
\DoxyCodeLine{269       MnvH2D * a;}
\DoxyCodeLine{270       MnvH2D * b;}
\DoxyCodeLine{271       MnvH2D * c;}
\DoxyCodeLine{272       \textcolor{keywordtype}{bool} t= m\_response[tag]-\/>GetMigrationObjects(a, b, c);}
\DoxyCodeLine{273       std::cout << \textcolor{stringliteral}{"{}RESPONSE "{}} << tag << \textcolor{stringliteral}{"{} "{}} <<  a-\/>GetName() << std::endl;}
\DoxyCodeLine{274       a-\/>Delete();}
\DoxyCodeLine{275       b-\/>Delete();}
\DoxyCodeLine{276       c-\/>Delete();}
\DoxyCodeLine{277     \}}
\DoxyCodeLine{278     \textcolor{keywordtype}{int} iuniv = m\_decoder[univ];}
\DoxyCodeLine{279     \textcolor{comment}{//std::cout << "{} fillresponse "{} << name << "{} "{} << iuniv << std::endl;}}
\DoxyCodeLine{280     m\_response[tag]-\/>Fill(x\_value, y\_value, x\_truth, y\_truth, name, iuniv, weight*scale);}
\DoxyCodeLine{281   \}}
\DoxyCodeLine{282 }
\DoxyCodeLine{283   \textcolor{keyword}{inline} \textcolor{keywordtype}{int} GetNhists()\{\textcolor{keywordflow}{return} m\_hists.size();\}}
\DoxyCodeLine{284 }
\DoxyCodeLine{285   \textcolor{keyword}{inline} MnvH2D* GetHist(\textcolor{keyword}{const} std::string tag)\{}
\DoxyCodeLine{286     \textcolor{keywordflow}{if} (m\_hists.count(tag)>0) \textcolor{keywordflow}{return} m\_hists[tag].hist;}
\DoxyCodeLine{287     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{288   \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290   \textcolor{keyword}{inline} MinervaUnfold::MnvResponse* GetResponse(\textcolor{keyword}{const} std::string tag)\{}
\DoxyCodeLine{291     \textcolor{keywordflow}{if} (m\_response.count(tag)>0) \textcolor{keywordflow}{return} m\_response[tag];}
\DoxyCodeLine{292     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{293   \}}
\DoxyCodeLine{294 }
\DoxyCodeLine{295   \textcolor{keyword}{inline} MnvH2D* GetMigrationMatrix(\textcolor{keyword}{const} std::string tag)\{}
\DoxyCodeLine{296     MnvH2D* matrix;}
\DoxyCodeLine{297     MnvH1D* dummy; \textcolor{comment}{//why are these here?}}
\DoxyCodeLine{298     MnvH1D* dummy2;}
\DoxyCodeLine{299 }
\DoxyCodeLine{300     \textcolor{keywordflow}{if} (m\_response.count(tag)>0)\{}
\DoxyCodeLine{301 \textcolor{preprocessor}{\#ifdef HSTDBG}}
\DoxyCodeLine{302       std::cout << \textcolor{stringliteral}{"{} HistWrapperMap::Migration matrix has size "{}} << m\_response[tag]-\/>GetMigrationMatrix()-\/>GetErrorBandNames().size() << std::endl;}
\DoxyCodeLine{303       std::cout << \textcolor{stringliteral}{"{} HistWrapperMap::getting migration matrix "{}} << m\_response[tag]-\/>GetMigrationMatrix()-\/>GetName() << std::endl;}
\DoxyCodeLine{304 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{305       matrix = m\_response[tag]-\/>GetMigrationMatrix();}
\DoxyCodeLine{306       \textcolor{keywordflow}{return} matrix;}
\DoxyCodeLine{307     \}}
\DoxyCodeLine{308     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{309   \}}
\DoxyCodeLine{310 }
\DoxyCodeLine{311 }
\DoxyCodeLine{312 }
\DoxyCodeLine{313 }
\DoxyCodeLine{314   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} Scale(\textcolor{keyword}{const} std::string tag, \textcolor{keywordtype}{double} scale)\{}
\DoxyCodeLine{315     m\_hists[tag].hist-\/>Scale(scale);}
\DoxyCodeLine{316   \}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} Write(\textcolor{keyword}{const} std::string tag, Int\_t option = 0)\{}
\DoxyCodeLine{319 }
\DoxyCodeLine{320       std::cout << \textcolor{stringliteral}{"{} look at all tags "{}} << tag << std::endl;}
\DoxyCodeLine{321       \textcolor{keywordflow}{if} (m\_hashist[tag])\{}
\DoxyCodeLine{322         std::cout << \textcolor{stringliteral}{"{} try to write hist "{}} << tag << \textcolor{stringliteral}{"{} "{}} << m\_hists[tag].hist-\/>GetName() <<  std::endl;}
\DoxyCodeLine{323         m\_hists[tag].hist-\/>Write();}
\DoxyCodeLine{324 }
\DoxyCodeLine{325       \}}
\DoxyCodeLine{326 }
\DoxyCodeLine{327 }
\DoxyCodeLine{328       \textcolor{keywordflow}{if}(m\_hasresponse[tag])\{}
\DoxyCodeLine{329         std::cout << \textcolor{stringliteral}{"{} try to write response "{}} << tag << \textcolor{stringliteral}{"{} "{}} << m\_hists[tag].hist-\/>GetName()  << std::endl;}
\DoxyCodeLine{330         PlotUtils::MnvH2D* h\_migration;}
\DoxyCodeLine{331         PlotUtils::MnvH2D* h\_reco;}
\DoxyCodeLine{332         PlotUtils::MnvH2D* h\_truth;}
\DoxyCodeLine{333         \textcolor{comment}{//        h\_migration-\/>SetDirectory(0);}}
\DoxyCodeLine{334         \textcolor{comment}{//        h\_reco-\/>SetDirectory(0);}}
\DoxyCodeLine{335         \textcolor{comment}{//        h\_truth-\/>SetDirectory(0);}}
\DoxyCodeLine{336         std::cout << \textcolor{stringliteral}{"{} GetMigrationObjects will now complain because I passed it pointers to uninitiated MnvH2D/1D to fill please ignore"{}} << std::endl;}
\DoxyCodeLine{337         m\_response[tag]-\/>GetMigrationObjects( h\_migration, h\_reco, h\_truth);}
\DoxyCodeLine{338         std::cout << h\_migration << std::endl;}
\DoxyCodeLine{339         \textcolor{keywordflow}{if} (h\_reco-\/>GetEntries() > 0)\{}
\DoxyCodeLine{340           h\_migration-\/>Write();}
\DoxyCodeLine{341           h\_reco-\/>Write();}
\DoxyCodeLine{342           h\_truth-\/>Write();}
\DoxyCodeLine{343         \}}
\DoxyCodeLine{344 }
\DoxyCodeLine{345       \}}
\DoxyCodeLine{346 }
\DoxyCodeLine{347   \};}
\DoxyCodeLine{348 }
\DoxyCodeLine{349 }
\DoxyCodeLine{350   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} DeleteResponse()\{}
\DoxyCodeLine{351     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} resp: m\_response)\{}
\DoxyCodeLine{352       std::cout << \textcolor{stringliteral}{"{}delete migration matrix"{}} << resp.second-\/>GetMigrationMatrix()-\/>GetName() ;}
\DoxyCodeLine{353       \textcolor{keyword}{delete} resp.second;}
\DoxyCodeLine{354     \}}
\DoxyCodeLine{355   \}}
\DoxyCodeLine{356 }
\DoxyCodeLine{357   \textcolor{comment}{// voodoo you sometimes need}}
\DoxyCodeLine{358   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} SyncCVHistos()\{}
\DoxyCodeLine{359     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} tag:m\_tags)\{}
\DoxyCodeLine{360       m\_hists[tag].SyncCVHistos();}
\DoxyCodeLine{361     \}}
\DoxyCodeLine{362   \};}
\DoxyCodeLine{363 }
\DoxyCodeLine{364 }
\DoxyCodeLine{365 \};}
\DoxyCodeLine{366 \};}
\DoxyCodeLine{367 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* Hist2DWrapperMap\_h */}\textcolor{preprocessor}{}}

\end{DoxyCode}
